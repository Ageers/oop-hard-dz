## Сюжет

Вы проектируете упрощённое ядро для сервиса Слоты доставки. Пользователь выбирает времное окно (слот) и оформляет заказ.
Нужно описать доменные сущности, контракты (интерфейсы), валидаторы и простую бизнес-логику бронирования слота.

Базовый вариант хранит время в
`long` (UNIX epoch, миллисекунды). Допзадание — работа с форматированием и операциями над временем.
---

## Доп обозначения:

paramName? - необязательный параметр, то есть может быть null.

## Обязательные требования

### 1) Интерфейсы

Спроектируйте как минимум три интерфейса:

1. **Identifiable** — контракт для сущностей с идентификатором.

    * Назначение: единый доступ к `long id`.
    * Использование: любая доменная сущность (например, Slot, Order, User) должна его реализовывать.

2. **Validatable** — контракт валидации.

    * Метод(ы): распечатать ошибки валидации и выбросить исключение.
    * Принцип: Печатаем все ошибки и возвращаем true только если ошибок нет.

3. **SlotPricing**  — контракт расчёта стоимости слота.

    * Методы: рассчитать цену по базовой ставке с учётом периода + отдельно рассчитать стоимость, если у клиента есть
      промокод
    * Должны быть две реализации - Фиксированная цена и Цена с учетом промокода.

---

### 2) Статические поля и методы

Используйте **статические члены**:

* **Генератор идентификаторов**: статическое поле-счётчик и статический метод `nextId()`
* **Утилиты валидации**: статический методы для общих проверок (например,
  `notBlank - длина строки без учета пробелов > 0`, `positive`,
  `requireBefore(start, end)`).

---

### 3) Доменная модель (минимум)

Опишите следующие сущности и связи:

* **User** (покупатель): `id`, `email`, `fullName`, `createdAt`, `promoCode?`.
* **Slot** (временное окно): `id`, `startAt`, `endAt`, `basePriceCents`, `status` (ENUM
  AVAILABLE/BOOKED).
    * Валидация: `startAt < endAt`, .
* **Order** (заказ на слот): `id`, `userId`, `slotId`, `createdAt`, `priceCents`, `status` (ENUM
  CREATED/PAID/CANCELLED).

Каждая сущность должна:

* реализовывать `Identifiable` и `Validatable`;
* иметь **валидацию полей** (см. раздел Правила валидации);
* иметь человекочитаемый вывод - то есть `toString()`

---

### 4) Бизнес-операции

Опишите сервис бронирования с интерфейсом (например, `SlotBookingService`) и такими операциями:

1. **bookSlot(userId, slotId)** — оформить бронирование (BOOKED) и создать Order.
    * Рассчитать цену через `SlotPricing`.
    * Вернуть Order со статусом CREATED.

2. **cancelOrder(orderId)** — отменить заказ.
    * Вернуть слот в доступное состояние.

---

### 5) Правила валидации

Реализуйте эти проверки:

* **User**: `email` не пустой и содержит `@`; `fullName` не короче N символов; `createdAt <= now`.
* **Slot**: `startAt < endAt` (оба в миллисекундах UNIX),`basePriceCents >= 0`.
  Периоды слотов одного дня не должны перекрываться (обоснуйте выбранную стратегию проверки).
* **Order**: `userId` и `slotId` существуют; `createdAt <= now`; `priceCents >= 0`.
* **Операции**: запрет ретроспективного бронирования — нельзя удерживать/бронировать слоты, которые уже начались или
  прошли.

## Дополнительное задание: работа с датой и временем

1. **Форматирование и парсинг:**
    * Реализуйте утилиту, которая преобразует `long` в ISO-строки вида `YYYY-MM-DDTHH:mm:ssZ` и обратно.

2. **Окна и длительности:**
    * Рассчитайте длительность слота в минутах/часах (из `startAt`, `endAt`).
    * Добавьте проверку удержание активно N минут — сравнение с `now`.

---

## Подсказки по дизайну (без кода)

* Начните с интерфейсов: **что обещает тип**, а не как устроен.
* Большие проверки разбейте на маленькие статические утилиты
* Для времени придерживайтесь одной политики: **храним в UTC в миллисекундах**
* Цена — целые копейки (`priceCents`).
